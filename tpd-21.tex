\documentclass[10pt,journal,compsoc]{IEEEtran}

\usepackage{verbatim}
\usepackage{url}
\usepackage{graphicx}

\usepackage{xspace}
\newcommand{\FC}       {Freechains\xspace}
\newcommand{\reps}     {\emph{reps}\xspace}
\newcommand{\onerep}   {\emph{1~rep}\xspace}
\newcommand{\nreps}[1] {\emph{#1~reps\xspace}}

\newcommand{\Xon} {$1{\rightarrow}N$\xspace}
\newcommand{\Xno} {$1{\leftarrow}N$\xspace}
\newcommand{\Xnn} {$N{\leftrightarrow}N$\xspace}
\newcommand{\Xoo} {$1{\leftrightarrow}1$\xspace}
\newcommand{\Xo}  {$1{\hookleftarrow}$\xspace}

\begin{comment}
- content                                                                       
- CPU work to create blocks, easy objective verification, 50+1 attack, collapse
- Human work to create content, easy subjective verification, 50+1 attack,
  community fork (actually encouraged)
- unique identity based on CPU
- here based on post quality
- not CDN: Content delivery network                                             

(b) double spend of coins/reps is solved by total ordering all
Users can like \& dislike posts, which transfer reputation between them.
Reputation is created from news

Just like Bitcoin reaches consensus with the longest chain
uses mining to

(excess, SPAM, fake, abuse, illegal)                                            
\end{comment}

\begin{document}
\title{
    Peer-to-Peer Consensus via Authoring Reputation
}
\author{
    Francisco Sant'Anna~\IEEEmembership{Department of Computer Science, Rio de Janeiro State University}
}

\IEEEtitleabstractindextext{%
\begin{abstract}
Content publishing in public Internet forums and social media suffers from
excess and abuse, such as low quality posts and fake news.
Centralized platforms employ filtering algorithms and anti-abuse policies, but
impose full trust from users.
We propose a publish-subscribe peer-to-peer protocol to model public content
dissemination without centralized control.
Abuse is mitigated with a reputation system that moderates content and, at the
same time, delivers network consensus.
We trace a parallel with Bitcoin:
    posts create reputation (vs proof-of-work),
    likes and dislikes transfer reputation (vs transactions),
    and aggregate reputation determines consensus (vs longest chain).
The reputation system depends solely on human work to create and rate content,
preventing abuse while imposing consensus on a peer-to-peer setting.
\end{abstract}

\begin{IEEEkeywords}
distributed consensus, peer-to-peer, publish-subscribe, reputation system
\end{IEEEkeywords}}

\maketitle

\section{Introduction}
\label{sec.introduction}

\IEEEPARstart{C}{ontent} publishing in public Internet forums and social media
platforms is increasingly more centralized in the hands of a few
companies~\cite{internet.fixing}.
%
On the one hand, these companies offer free storage, friendly user interfaces,
and robust access.
On the other hand, they concentrate more power than required to operate, since
they collect and control our data, ``algorithmize'' our consumption, and yet
obstruct portability with proprietary standards.
%
Peer-to-peer alternatives~\cite{p2p.survey} eliminate intermediaries and push
to end users the responsibility to manage data and connectivity.
However, due to decentralization of authority and network infrastructure, some
new challenges arise to deal with malicious users and enforce overall state
consistency.

In an ideal Internet forum, all messages or posts
(i)   reach even temporarily disconnected users;
(ii)  are delivered in a consistent order;
(iii) are respectful and on topic.
In a centralized system, items (i) and (ii) are trivially achieved assuming
availability and delivery order in the service, while for item (iii) users have
to trust the service to moderate content.
In a decentralized setting, however, none of these demands are easily
accomplished.
A common approach in gossiping protocols is to replicate the whole conversation
in all peers and disseminate it proactively until all users receive
it~\cite{p2p.survey}.
However, this approach does not guarantee consensus since posts can be received
in conflicting orders in different peers.
As an example, antagonistic messages such as \emph{"X is final"} vs
\emph{"Y is final"} might be sent concurrently, preventing the network to
decide as a group between \emph{X} and \emph{Y}.

Bitcoin~\cite{p2p.bitcoin} proposes a permissionless consensus protocol founded
on scarce virtual assets, the \emph{bitcoin tokens}.
%
The only way to create new bitcoins is to work towards consensus in the network
by proposing a total order among all transactions in the system.
%
This way, Bitcoin prevents double spending~\cite{p2p.bitcoin}, which is
analogous to conflicting messages in public discussions:
    deciding between \emph{X} and \emph{Y} as a group is the same as
    transferring bitcoins to \emph{X} and \emph{Y} with insufficient funds for
    both.
%
However, Bitcoin just blindly transfers bitcoins between users, with no
subjective judgment that could affect the actual transactions.
In contrast, our challenge is to use social interactions between humans to
evaluate content and mitigate abuse.

In this work, we propose a consensus algorithm based on authoring reputation.
Inspired by Bitcoin, authors accumulate tokens named \reps, which serve as
currency to rate posts in the network.
Users can rate posts with likes and dislikes, which transfer \reps between
them.
Work is manifested as new posts which, if accepted by others, reward authors
with \reps.
This way, like Bitcoin, token generation is expensive, while verification is
cheap and made by multiple users.
However, unlike Bitcoin, both creation and verification are subjective, based
on human creativity and judgement, which match our target domain of content
publishing.
Posts and likes are linked as blocks in a Merkle~DAG that persists the whole
conversation and is disseminated in the network with gossiping.
To reach consensus, the DAG is sequenced as a linked list that orders branches
with more reputed authors first (i.e., branches with more work).
The list is then verified for conflicting operations, such as likes with
insufficient \reps, which is equivalent to double spending in Bitcoin.
In this case, the branch that causes the conflict, which is always the one with
less work, is removed from the DAG and the linked list is recalculated.
We integrated the proposed consensus algorithm into Freechains%
\footnote{\url{http://www.freechains.org}},
a peer-to-peer publish-subscribe content dissemination
protocol~\cite{fcs.sbseg20}.

Our main contribution is to make public forums practical with complete
decentralization.
The proposed reputation system depends solely on human work to create and
moderate content.
It can be applied to any public forum system that uses DAGs to structure its
messages.

\begin{figure*}[ht]
\centering
\includegraphics[width=\textwidth]{arrangements.png}
\caption{The three types of chains and arrangements in \FC.}
\label{fig.table}
\end{figure*}

In Section~\ref{sec.freechains}, we introduce the basic functionalities of \FC
to create, rate, and disseminate posts.
In Section~\ref{sec.consensus}, we describe the general design of the consensus
algorithm and how we applied it to \FC.
In Section~\ref{sec.related}, xxx.
In Section~\ref{sec.conclusion}, yyy.

\section{Freechains}
\label{sec.freechains}

\FC is an unstructured peer-to-peer topic-based publish-subscribe
system~\cite{fcs.sbseg20}.
Each topic, or \emph{chain}, is organized as a \emph{Merkle DAG}, i.e., a
directed acyclic graph immune to modifications.
The chain DAG is disseminated peer by peer in the network with gossiping.
This way, as an author posts to a chain, other users subscribed to the same
chain eventually receive the message.
\FC supports multiple types of chains with different arrangements of public and
private communication, which are detailed in Figure~\ref{fig.table}.
In this section, we operate a private group to describe the basic behavior of
chains.
At the end of the section, we also exemplify a public identity chain.
In Section~\ref{sec.consensus}, we detail the behavior of public forums, which
involve untrusted communication between users and require the proposed
reputation and consensus mechanisms.

All \FC operations go through a \emph{daemon} (analogous to Bitcoin full nodes)
which validates posts, links them in the Merkle DAGs, persists the chains in
the disk, and communicates with other peers in the network to disseminate the
graphs.
The command that follows starts a daemon to serve further operations:

{\footnotesize
\begin{verbatim}
 > freechains-daemon start '/var/freechains/'
\end{verbatim}
}

The actual chain operations use a separate client to communicate with the
daemon.
The next sequence of commands (i) creates a shared key, (ii) joins a private
group chain (prefix $\$$), and (iii) posts a message into the chain:

{\footnotesize
\begin{verbatim}
 > freechains crypto shared 'strong-password' # (i)
 A6135D..   <- returned shared key
 > freechains '$family' join 'A6135D..'       # (ii)
 42209B..   <- hash of chain
 > freechains '$family' post 'Good morning!'  # (iii)
 1_EF5DE3.. <- hash of post
\end{verbatim}
}

\begin{figure}[t]
\centering
\includegraphics[width=0.5\textwidth]{family.png}
\caption{Two DAG configurations. (A) has a single head pointing to the
genesis block. (B) has a fork with two heads pointing to the genesis block.}
\label{fig.family}
\end{figure}

A private chain requires that all participants use the same shared key to join
the group.
A \emph{join} only initializes the DAG locally in the file system, and a
\emph{post} also only modifies the local structure.
No communication occurs at this point.
Figure~\ref{fig.family}.A depicts the state of the chain after the first post.
The genesis block with height $0$ and hash \texttt{42209B..}
depends only on the arguments given to \emph{join}.
The next block with height $1$ and hash \texttt{EF5DE3..} contains the posted
message.
As expected from a Merkle~DAG, the hash of a block depends on its payload and
hash of previous block.

\FC adheres to the \emph{local-first} software principle~\cite{p2p.local},
allowing networked applications to host their own data and work locally while
offline.
Except for synchronization, all other operations in the system only affect the
local replica.
In particular, joining a chain with the same arguments in another peer results
in the same genesis state, even if the peers have never met before.
Hence, before synchronizing, others peers have to initialize the example chain
with the same steps:

{\footnotesize
\begin{verbatim}
 > freechains-daemon start '/var/freechains/'
 > freechains crypto shared 'strong-password'
 A6135D..
 > freechains '$family' join 'A6135D..'
 42209B..
\end{verbatim}
}

Synchronization is explicit, in pairs, and unidirectional.
The command \emph{recv} asks daemon in \emph{localhost} to connect to daemon in
\emph{remote-ip} and receive all missing blocks from there:

{\footnotesize
\begin{verbatim}
 > freechains '$family' recv '<remote-ip>'
 1/1  <- one block received from <remote-ip>
\end{verbatim}
}

The complementary command \emph{send} synchronizes the DAGs in the other
direction.
Note that \FC does not construct a network topology or synchronize peers
automatically.
There are no preconfigured peers, no root servers, no peer discovery.
All connections happen through the \emph{send} and \emph{recv} commands which
have to specify the peers explicitly.
In this sense, the protocol only gives basic support for communication in pairs
of peers and any further automation requires external tools.

The next sequence of commands checks the hash(es) of the block(s) at the head
of the local DAG (the latest blocks), and then reads the payload of the single
head found:

{\footnotesize
\begin{verbatim}
 > freechains '$family' heads
 1_EF5DE3..
 > freechains '$family' payload '1_EF5DE3..'
 Good morning!
\end{verbatim}
}

Now, the new peer is in the same state as the original peer in
Figure~\ref{fig.family}.A.
However, since the network is inherently concurrent and users are encouraged to
work locally, typical graphs are not lists, but DAGs with multiple heads.
As an example, suppose the new peer posts a message "I'm here!" \textbf{before}
the \emph{recv} above, when the local DAG is still in its genesis state.
In this case, as illustrated in Figure~\ref{fig.family}.B, the resulting graph
after the synchronization now contains two blocks with height $1$.
%
Note that forks in the DAG create ambiguity in the order of messages, which is
the fundamental obstacle to reach consensus.
In private chains, which we use in this example, we can apply simple methods to
reach consensus, such as relying on the timestamps of blocks.
However, in public forums, a malicious user can modify his local time to affect
new block timestamps and manipulate the order of messages.

To conclude the basic chain operations, users can rate posts with \emph{likes}
and \emph{dislikes}, which can be consulted later:

{\footnotesize
\begin{verbatim}
 > freechains '$family' like '1_EF5DE3..'
 2_BF3319..
 > freechains '$family' reps '1_EF5DE3..'
 1  # post received 1 like
\end{verbatim}
}

In private groups, likes are unlimited and behave much like typical centralized
systems.
In public forums, however, likes are restricted, have to be signed by users,
and are at the core of the consensus algorithm.

For the sake of completeness, \FC also supports public identity chains (prefix
$@$), which relies on public-key cryptography to attach an identity to a chain
and verify the authenticity of posts:

{\footnotesize
\begin{verbatim}
 > freechains crypto pubpvt 'other-password'
 EB172E.. 96700A..   <- public and private keys
 > freechains '@EB172E..' join
 F4EE21..
 > freechains '@EB172E..' post 'This is Pele' \
    --sign='96700A..'
 1_547A2D..
\end{verbatim}
}

In the example, a public figure creates a pair of public/private keys and joins
an identity chain attached to his public key.
Every post in this chain needs to be signed with the associated private key to
be accepted in the network.

\section{The Consensus Algorithm}
\label{sec.consensus}

In the absence of moderation, peer-to-peer public forums are impractical.
At the root of the problem lies Sybil attacks, which use large numbers of fake
identities to abuse the system.
For instance, it should take a few seconds to generate thousands of
public/private key identities and SPAM million of messages into the system.
%Hence, without moderation, there are no limits on the number and size of posts
%and no reasonable policy to distinguish quality.
For this reason, we propose a reputation system that works together with a
consensus algorithm to mitigate Sybil attacks and make peer-to-peer public
forums practical.

Section~\ref{sec.consensus.design} describes the overall consensus rules which
can be applied to any public forum system that uses DAGs to structure its
messages.
Section~\ref{sec.consensus.chains} describes the concrete rules we chose for
the public forums of \FC.

\subsection{Overall Design}
\label{sec.consensus.design}

In the proposed reputation system, users can spend tokens named \reps to post
and rate content in the forums:
a \emph{post} operation initially penalizes authors until it consolidates and
counts positively;
a \emph{like} operation is a positive feedback that helps subscribers
distinguish good content amid excess;
a \emph{dislike} operation is a negative feedback that revokes content when
crossing a threshold.
%
However, without restrictions, posts and likes alone are not satisfactory in
the presence of Sybils.
Therefore, \reps must be subject to some sort of scarcity that demands
non-trivial work immune to automation.

Bitcoin employs CPU proof-of-work to mitigate Sybil attacks.
However, in the context of content publishing, we understand that authoring is
already an intrinsic human work that we can take advantage.
Creating new content is hard and takes time, but is comparatively easy to
verify and rate.
Therefore, in order to impose scarcity, only content authoring generates \reps,
while likes and dislikes only transfer \reps between users.
%but limited by periods of time to prevent excess (e.g., once in a day per user).
%Additionally,
%
Still, scarce posts and likes are not yet enough because they demand consensus
in the network.
Now, we need to track the reputation of users to check if they are allowed to
post new messages or spend likes.
Since posts and likes are concurrent in the network, we need to figure out how
to order them consistently across all peers so that they converge to the same
state.
As an example, it is possible that an author with a single unit of \reps
receives a dislike at the same time he posts a new message in the network.
If accounted before, the dislike blocks the new post, otherwise the post is
valid.
Even though it is impossible to determine which action happened first, the
network as a whole needs to agree on a single order because it affects all
future operations.

\begin{figure}[t]
\centering
\includegraphics[width=0.49\textwidth]{reps2.png}
\caption{
    (A) A public forum DAG with a common prefix and two branches.
    (B) Total order between blocks of the DAG.
}
\label{fig.reps}
\end{figure}

\begin{figure*}[ht]
\centering
\includegraphics[width=\textwidth]{rules.png}
\caption{Reputation rules for public forum chains.}
\label{fig.rules}
\end{figure*}

Our solution is to order posts in the network favoring forks with participants
that constitute the majority of reputation.
This way, in order to manipulate consensus, malicious users first need to
cooperate to gain reputation, which is a non-trivial work and contradicts their
intent.
%
Figure~\ref{fig.reps}.A illustrates the reputation criterion.
%, still abstractly, since we did not discuss the actual rules for content creation and rating.
A public forum DAG has a common prefix with signed posts from users $a$, $b$,
and $c$.
Let's assume that within the prefix, users $a$ and $b$ have contributed with
more content and have more reputation combined than $c$ has alone.
%
After the prefix, the forum forks in two branches:
in \emph{branch~1}, only user $c$ remains active and we see that new users $x$
and $y$, with no previous reputation, generate a lot of new content;
in \emph{branch~2}, only users $a$ and $b$ participate but with less activity.
Nonetheless, \emph{branch~2} takes priority because, at the forking point, $a$
and $b$ have more reputation than $c$, $x$, and $y$ combined.
%
User $c$ here represents a malicious user trying to cultivate fake identities
$x$ and $y$ in separate of the network to accumulate \reps.
However, the whole \emph{branch~1} becomes vulnerable because \emph{branch~2}
takes priority and can overthrow user $c$ as discussed further.

Figure~\ref{fig.reps}.B indicates the consensus order between blocks in the
forum.
All operations in \emph{branch~2} are accounted before any operation in
\emph{branch~1}.
%
At any point in the consensus timeline, if an operation fails, all remaining
blocks in the offending branch are removed from the forum DAG.
As an example, suppose the last post by $a$ (in gray) is a dislike to user $c$,
which decreases its reputation.
Then, it's possible that the last post by $c$ (in red) is rejected together
with all posts by $y$ and $x$ in sequence.
%
Unlike Bitcoin, forks are not only allowed but encouraged due to the
local-first principle.
The resulting ordered list is only a view of the primary DAG structure.
However, the longer a peer remains disconnected, the more conflicting
operations it may perform, and the higher are the chances of rejection when
rejoining.
%
Note that users in \emph{branch~2} with more reputation may judge
\emph{branch~1} as malicious and can react even after the fact.
For instance, users $a$ and $b$ can post extra dislikes in \emph{branch~2} so
that merging with \emph{branch~1} removes all of its blocks.
It is also possible that users disagree with the consensus protocol and want to
fork the forum permanently.
We discuss these countermeasures in Section~\ref{sec.TODO}.

Some other considerations about merging forks:
Peers that received branches with less reputation first (\emph{branch~1}) will
need to reorder all blocks starting at the forking point.
This might even involve removing content in the end user software.
This behavior is similar to blockchain reorganization in Bitcoin when a peer
detects a new longest chain and disconsiders old blocks.
%
Likewise, peers that saw branches with more reputation first (\emph{branch~2})
just need to put the other branch in sequence and do not need to recompute
anything.
This should be the normal behavior and is expected to happen in the majority of
the network.

\begin{comment}
As a last remark, let's assume that user $c$ is malicious and is trying to use
Sybils $x$ and $y$ to multiply content generation during a certain period and
collect enough \reps in separate of the network to perform an attack later.
Even though the blocks of \emph{branch 1} would appear after \emph{branch 2},
they could still be successful to collect the intended \reps.
However, if the majority of the network in \emph{branch 2} notices that the
messages in \emph{branch 1} are malicious, they can still defend themselves:
Since they have more reputation Users $a$ and $b$ can pretend that they did not see \emph{branch 1} and post
dislikes to $c$ at the end of \emph{branch 2} which .
\end{comment}

\subsection{Public Forum Chains}
\label{sec.consensus.chains}

We integrated the proposed reputation system in the public forums of \FC to
support content moderation and enforce consensus in the chains.
Figure~\ref{fig.rules} details the concrete rules which are discussed as
follows.
Authors have to sign their posts in order to be accounted by the reputation
system and operate in the chains.
The next example creates an identity whose public key is assigned as the
pioneer in the public chain (prefix $\#$):

{\footnotesize
\begin{verbatim}
 > freechains crypto pubpvt 'pioneer-password'
 4B56AD.. DA3B5F..
 > freechains '#forum' join '4B56AD..'
 10AE3E..
 > freechains '#forum' post --sign='DA3B5F..' \
    'The purpose of this chain is...'
 1_CC2184..
\end{verbatim}
}

The \emph{join} command in rule~\texttt{1.a} bootstraps a public chain,
assigning \nreps{30} to the pioneer referred in the public key.
The pioneer shapes the initial culture of the chain with its first posts and
likes, while gradually transferring \reps to other authors, which may also
transfer to other authors, expanding the community.
%
In this regard, the \emph{post} command above, signed by the pioneer, indicates
the purpose of the chain to other users joining.
%
Note that chains with the same name but different pioneers are incompatible
because the hash of genesis blocks also depend on the pioneers' public keys.

Our most basic concern in public forums is to resist Sybils spamming the chains
with new posts.
Fully peer-to-peer systems cannot rely on identity logins or CAPTCHAs due
to the lack of a central authority.
Other alternatives include (i) building social trust graphs, in which users
already in the community vouch for new users, or (ii) imposing economic costs
for new posts, such as proof of work.

We propose a mix between trust graphs and economic costs.
% with the basic premise that users with no previous reputation are not allowed to post.
Rule~\texttt{4.a} imposes that authors require at least \onerep to post, while
rule~\texttt{2} imposes a cost of \onerep to post, even for existing users.
These rules combined prevents Sybils to abuse the system.
Rule~\texttt{3.a} allows an existing user to like a new user's post, which
unblocks the post and vouches for the new user, but also at the cost of
\onerep.
%These rules impose costs not only for welcoming new users, but also for posting
%new messages, which also prevents abuse from malicious users already in the
%chain.
%
Note that the pioneer rule~\texttt{1.a} solves the chicken-and-egg problem
imposed by rule~\texttt{4.a}.

The next commands illustrate the reputation rules with numbers.
A new user joins the same public chain as before and posts a new message, which
is welcomed with a like signed by the pioneer:

{\footnotesize
\begin{verbatim}
 > freechains crypto pubpvt 'new-author-password'
 503AB5.. 41DDF1..
 > freechains '#forum' join '4B56AD..'
 10AE3E..  <-- same pioneer as before
 > freechains '#forum' post 'I'm a newbie...' \
    --sign='41DDF1..'
 2_C3A40F..
 > freechains '#forum' like '2_C3A40F..' \
    --sign='DA3B5F..'
 3_59F3E1..
\end{verbatim}
}

\begin{figure}[ht]
\centering
\includegraphics[width=0.49\textwidth]{forum.png}
\caption{
    The \texttt{like} approves the newbie message into the \texttt{\#forum} DAG.
}
\label{fig.forum}
\end{figure}

Figure~\ref{fig.forum} illustrates the chain DAG up to the like operation.
The pioneer starts with \nreps{30} (rule~\texttt{1.a}) and posts an initial
message, reducing his balance to \nreps{29} (rule~\texttt{2}).
Then, a new user with \nreps{0} tries to post a message
(hash~\texttt{C3A40F..}), which is initially blocked (rule~\texttt{4.a}), as
the red background highlights.
Then, the pioneer likes the blocked message, which reduces himself to
\nreps{28} and increments new user to \onerep (rule~\texttt{3.a}), which is
immediately consumed by the blocked post to become accepted.
At the end, the pioneer has \nreps{28} and the new user remains with \nreps{0}
but with his post accepted.
Note that the overall balance after the commands above is -\nreps{2} due to the
penalties of the two post operations (rule~\texttt{2}).
After at most 12 hours, these penalties are dismissed and the \nreps{2} are
recovered (rule~\texttt{2}):
    the pioneer goes to \nreps{29} and the new user to \onerep, which sum up to
    the pioneer's original \nreps{30}.

With no additional rules to generate \reps, the initial \nreps{30} would
constitute the whole ``chain economy'' forever.
For this reason, rule~\texttt{1.b} awards authors 24 hours after a new post
with \onerep.
This rule stimulates content creation and grows the economy of chains.
The 24-hour period allows other users to judge the post before awarding the
author, and also regulates the growth speed of the chain.
Therefore, after the commands above complete 1 day, the pioneer accumulates
\nreps{30} and the new user \nreps{2}, growing the economy in \nreps{2} as
result of the two consolidated posts.
Note that rule~\texttt{1.b} awards at most one post per day per author, i.e.,
with 10 posts in 7 days an author collects at most \nreps{7}.
Note also that rule~\texttt{4.b} limits authors to at most \nreps{30}, which
provides incentives to spend likes and thus decentralize the network.

Likes and dislikes (rules \texttt{3.a} and \texttt{3.b}) serve three purposes
in the chains:
    (a) welcoming new users, (b) measuring the quality of posts, and
    (c) censoring abuse (SPAM, fake news, illegal content).
%
The reputation of a given post is the difference between its likes and
dislikes, which can be used for end-user software for filtering and
highlighting purposes.
%
The quality of posts is subjective and is up to users to judge then with likes,
dislikes, or simply abstaining.
On the one hand, since \reps are finite, users need to ponder and avoid
indiscriminate expenditure.
On the other hand, since \reps are limited to at most \nreps{30} per author
(rule~\texttt{4.b}), users also have incentives to spend them.
Hence, the scarcity and limits work together towards the quality of the chains.
%
Note that a dislike shrinks the chain economy since it removes \reps from both
the origin and target.
As detailed next, the contents of a post may become hidden if it has at least 3
dislikes and the number of dislikes is higher than the number of likes
(rule~\texttt{3}).
However, considering that \reps are scarce, dislikes should be more directed to
combat abuse, but not much to eliminate divergence of opinion.

\begin{figure}[ht]
\centering
\includegraphics[width=0.49\textwidth]{state.png}
\caption{
    State machine of posts:
    \emph{BLOCKED} posts are not linked in the DAG.
    The payload of \emph{HIDDEN} posts are not retransmitted.
    \emph{ACCEPTED} posts are linked and retransmitted.
}
\label{fig.state}
\end{figure}

A post has three possible states: \emph{BLOCKED}, \emph{ACCEPTED}, or
\emph{HIDDEN}.
Figure~\ref{fig.state} specifies the transitions between the states.
%
If the author has reputation, its new post is immediately \emph{ACCEPTED} in
the chain.
Otherwise, it is \emph{BLOCKED} and requires a like from another user.
Blocked posts are not considered part of the chain DAG in the sense that new
posts do not link back to it.
%
Peers are not required to hold blocked posts and neither retransmit them to
other peers.
However, if blocked posts do not reach other users, they will never have the
chance to be welcomed with a like.
A reasonable policy for blocked posts is to hold them in a temporary bag and
retransmit them for some visibility in the network.
Rule~\texttt{4.c} limits the size of posts to at most \emph{128Kb} to prevent
DDoS attacks using gigantic blocked posts.
%
Once accepted, a post becomes part of the chain and can never be removed
again since Merkle DAGs are immutable by design.
%Note that blocked posts that become accepted are always succeeded by a
%\emph{like} (Figure~\ref{fig.forum}).
%
If the number of dislikes of a post exceeds the threshold, its payload becomes
\emph{HIDDEN} and is not retransmitted to other peers.
% and should be removed from local storage.
Since the Merkle DAG depends only on its hash, removing the actual payload is
harmless.
Also, the DAG itself contains the dislikes that prove the hidden state to other
peers.
Later, if the post receives new likes and changes its state, it means that the
payload is still known somewhere and peers can request it when synchronizing
again.

\subsection{TODO}

- users that work twice, bots

Terminar com "@!xxx" dizendo que vale reps mas que owner pode "intervene"

- summary
    - parallel w/ bitcoin
        - ponte entre reputacao -> sybil -> consenso
    - no problem w/ forks

We reach a similar solution to Bitcoin but adapted to our domain
- we need consensus to make the reputation system work
- we need reputation system to reach consensus
- same virutous cycle as bitcoin

The more CPU work is done, the stronger becomes the proposal, the more peers
follow it, the more tokens are mined.
There is a strong association between work, profit and consensus that enables
Bitcoin as a peer-to-peer cash system.

- reputation system to rate messages
    - positively (to distinguish from excess), or
    - negatively (to block SPAM, fake news, illegal content)
- some sort of scarcity (work)
    - you like you loose
    - you work you get
    - otherwise sybil, "likes" abuse
    - incentives for continuous, good quality posts
- consensus to ???

\section{Related Work}
\label{sec.related}

Bitcoin employs CPU proof-of-work as a solution, but did not solve the
centralization issue completely because the cost to perform work is not
equally distributed
(depends on costs of equipment and energy)
    - bitcoin demands connectivity to avoid forks
    - forks ok in freechains since operations are not critical and can be reverted
    - 50+1 attack easy in first nodes if not all nodes keep participating
        - freechains requires checkpoints

- related work public forums in scuttlebutt are permissioned (you decide who
  participates). each user has a completely different view of \#chat. not really
  public although some intersections
    - you can see an answer but not a question, or a question w/ no answers
      even if the best answer exists. no content discovery



\section{Conclusion}
\label{sec.conclusion}


Like \emph{bitcoins}, \reps are scarce, hard to generate, and easy to verify.
Unlike \emph{bitcoins}, \reps .


With this design, we retarget  , the balance between work, profit and consensus also applies 

attack 50+1 but not as
cite local-first software

 (crypto proof \& authoring),
while verification is cheap


requires work but evaluation


, but
are evaluated by other user
The system also imposes incentives to rate posts and 

Unlike bitcoin

Since likes and dislikes spend reputation, \emph{creps} are scarce resources
Incentives to post and rate content.

There is a strong association between work, profit and consensus that enables
Bitcoin as a peer-to-peer cash system.

distinguish SPAM from legitimate
Another problem CPU



content.



 (e.g., posts on social media, public conversations
based on the reputation of users
in the network.


biggest difference:
work is subjective as is the evaluation by other users


 with consensus since
whoever proposes the ordering will choose one of the operations arbitrarily


 which is similar to the
example above (\emph{buy X} vs \emph{buy Y})

spent

with work



this gives consensus with total order, solves double spend, which is equivalent
to solving X/Y is decided above

we borrow token, scarcity


 that requires work to 
Only one purpose


- incentive
- security

- Last-Write-Wins

- just all tokens are the same, no subjective judgment, for example on why token is being transferred


 and xx timestamps.


 of the service and , and trust from users to deal

In a decentralized setting, 
    - spam
    - abuse
    - on topic
    - disconnections
    - order

Bitcoin

responses would




n user posts 

- discovery
- also consensus, ensure that participants receive all data in a consistent order
- bitcoin, discovery even disconnected, consensus, but not quality


Regardless of the Internet growth over the years,

\subsection{Subsection Heading Here}
Subsection text here.

\subsubsection{Subsubsection Heading Here}
Subsubsection text here.

\section{Conclusion}
The conclusion goes here.

\bibliographystyle{IEEEtran}
\bibliography{tpd-21}

\begin{IEEEbiography}{Michael Shell}
Biography text here.
\end{IEEEbiography}

\begin{IEEEbiographynophoto}{John Doe}
Biography text here.
\end{IEEEbiographynophoto}

\begin{IEEEbiographynophoto}{Jane Doe}
Biography text here.
\end{IEEEbiographynophoto}

\end{document}
